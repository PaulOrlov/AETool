package ru.ptahi.aetexperiment;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.embed.swing.JFXPanel;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ToggleButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Lookup;
import org.openide.util.LookupEvent;
import org.openide.util.LookupListener;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.openide.util.Utilities;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//ru.ptahi.aetexperiment//VisualizerProperties//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "VisualizerPropertiesTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "properties", openAtStartup = false)
@ActionID(category = "Window", id = "ru.ptahi.aetexperiment.VisualizerPropertiesTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_VisualizerPropertiesAction",
        preferredID = "VisualizerPropertiesTopComponent"
)
@Messages({
    "CTL_VisualizerPropertiesAction=VisualizerProperties",
    "CTL_VisualizerPropertiesTopComponent=VisualizerProperties Window",
    "HINT_VisualizerPropertiesTopComponent=This is a VisualizerProperties window"
})
public final class VisualizerPropertiesTopComponent extends TopComponent implements LookupListener {

    private JFXPanel fxContainer;
    private final int JFXPANEL_WIDTH_INT = 400;
    private final int JFXPANEL_HEIGHT_INT = 600;
    private List<CheckBox> checkBoxList = new ArrayList<CheckBox>();
//    private Lookup.Result<ExperimentNode> experimentOnLookup;
    private ExperimentNode eNodeObj;
    private ArrayList<ChangeListener> clbList = new ArrayList<ChangeListener>();
//    private Button tb;
    private Label lb = new Label(" ");

    public VisualizerPropertiesTopComponent() {
        initComponents();
        setName(Bundle.CTL_VisualizerPropertiesTopComponent());
        setToolTipText(Bundle.HINT_VisualizerPropertiesTopComponent());
        putClientProperty(TopComponent.PROP_DRAGGING_DISABLED, Boolean.TRUE);
        setLayout(new BorderLayout());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
//        experimentOnLookup = Utilities.actionsGlobalContext().lookupResult(ExperimentNode.class);
//        experimentOnLookup.addLookupListener(this);

        fxContainer = new JFXPanel();
        fxContainer.setPreferredSize(new Dimension(JFXPANEL_WIDTH_INT, JFXPANEL_HEIGHT_INT));
        add(fxContainer, BorderLayout.CENTER);

        Platform.setImplicitExit(false);
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                createScene();
            }
        });
    }

    private void createScene() {
        StackPane root = new StackPane();

        CheckBox cb0 = new CheckBox("Fixation Duration");
        CheckBox cb1 = new CheckBox("Attributes");
        CheckBox cb2 = new CheckBox("Constructor");
        CheckBox cb3 = new CheckBox("Area");
        CheckBox cb4 = new CheckBox("Width");
        CheckBox cb5 = new CheckBox("Height");
        CheckBox cb6 = new CheckBox("Main");

        CheckBox cb7 = new CheckBox("Body");
        CheckBox cb8 = new CheckBox("Signature");
        CheckBox cb9 = new CheckBox("Return");

        CheckBox cb10 = new CheckBox("Type");
        CheckBox cb11 = new CheckBox("FormalParameterList");
        CheckBox cb12 = new CheckBox("Name");

        CheckBox cb13 = new CheckBox("ActualParameterList");
        CheckBox cb14 = new CheckBox("MethodCallName");
        CheckBox cb15 = new CheckBox("MethodCallType");

        CheckBox cb16 = new CheckBox("JumpControl");
        CheckBox cb17 = new CheckBox("LineScan");

        checkBoxList.add(cb0);
        checkBoxList.add(cb1);
        checkBoxList.add(cb2);
        checkBoxList.add(cb3);
        checkBoxList.add(cb4);
        checkBoxList.add(cb5);
        checkBoxList.add(cb6);
        checkBoxList.add(cb7);
        checkBoxList.add(cb8);
        checkBoxList.add(cb9);
        checkBoxList.add(cb10);
        checkBoxList.add(cb11);
        checkBoxList.add(cb12);
        checkBoxList.add(cb13);
        checkBoxList.add(cb14);
        checkBoxList.add(cb15);
        checkBoxList.add(cb16);
        checkBoxList.add(cb17);

        for (int i = 0; i < checkBoxList.size(); i++) {
            final CheckBox currentCb = checkBoxList.get(i);
            ChangeListener clb = new ChangeListener<Boolean>() {
                @Override
                public void changed(ObservableValue<? extends Boolean> ov, Boolean old_val, Boolean new_val) {
                    String annotationName = currentCb.getText();
                    if (new_val) {
                        eNodeObj.addActiveAnnotation(annotationName);
                    } else {
                        eNodeObj.removeActiveAnnotation(annotationName);
                    }
                }
            };
            currentCb.selectedProperty().addListener(clb);
//            clbList.add(i, clb);
        }

        VBox cb_block = new VBox();
        cb_block.setPadding(new Insets(10));
        cb_block.setSpacing(8);
        
        lb.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(lb);
        
        Text title = new Text("Eye movements");
        title.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(title);

        cb_block.getChildren().addAll(cb0);

        Text title2 = new Text("");
        title2.setFont(Font.font("Arial", FontWeight.BOLD, 7));
        cb_block.getChildren().add(title2);

        Text title1 = new Text("Block annotations");
        title1.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(title1);

        cb_block.getChildren().addAll(cb1, cb2, cb3, cb4, cb5, cb6);

        Text title3 = new Text("");
        title3.setFont(Font.font("Arial", FontWeight.BOLD, 7));
        cb_block.getChildren().add(title3);

        Text title4 = new Text("Sub-Block annotations");
        title4.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(title4);

        cb_block.getChildren().addAll(cb7, cb8, cb9);

        Text title5 = new Text("");
        title5.setFont(Font.font("Arial", FontWeight.BOLD, 7));
        cb_block.getChildren().add(title5);

        Text title6 = new Text("Signatura annotations");
        title6.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(title6);

        cb_block.getChildren().addAll(cb10, cb11, cb12);

        Text title7 = new Text("");
        title7.setFont(Font.font("Arial", FontWeight.BOLD, 7));
        cb_block.getChildren().add(title7);

        Text title8 = new Text("Method-Call annotations");
        title8.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(title8);

        cb_block.getChildren().addAll(cb13, cb14, cb15);

        Text title9 = new Text("");
        title9.setFont(Font.font("Arial", FontWeight.BOLD, 7));
        cb_block.getChildren().add(title9);

        Text title10 = new Text("Pattern annotations");
        title10.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        cb_block.getChildren().add(title10);

        cb_block.getChildren().addAll(cb16, cb17);

        ScrollPane sp = new ScrollPane();
        sp.setContent(cb_block);
        root.getChildren().add(sp);
        
        Scene scene = new Scene(root);
        fxContainer.setScene(scene);
    }

    @Override
    public void componentClosed() {
        //experimentOnLookup.removeLookupListener(this);
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public void resultChanged(LookupEvent le) {
//        if (!experimentOnLookup.allInstances().isEmpty()) {
//            eNodeObj = experimentOnLookup.allInstances().iterator().next();
//            if (eNodeObj != null) {
//                activeAnnotationsNames = eNodeObj.getActiveAnnotations();
//                upDateScene();
//            }
//        }
    }

    private void upDateScene() {
//        boolean fVisibility = eNodeObj.isVisible();
//        tb.setSelected(fVisibility);
        ArrayList<String> tmpList = (ArrayList) eNodeObj.getActiveAnnotations().clone();
        for (CheckBox currentCb : checkBoxList) {
            currentCb.setSelected(false);
        }
        for (String currentAnnotationName : tmpList) {
            for (CheckBox currentCb : checkBoxList) {
                if (currentCb.getText().equals(currentAnnotationName)) {
                    currentCb.setSelected(true);
                }
            }
        }
    }

    void setExperimentNode(ExperimentNode expNode) {
        eNodeObj = expNode;
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                lb.setText(eNodeObj.getDisplayName());
            }
        });
        
        upDateScene();
    }
}
